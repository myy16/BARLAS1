#!/usr/bin/env python3
"""
TEKNOFEST SLAM Navigasyon Sistemi
LiDAR verilerini kullanarak harita olu≈üturma ve otonom navigasyon
"""

import rospy
import tf2_ros
import tf2_geometry_msgs
import numpy as np
import math
from geometry_msgs.msg import Twist, PoseStamped, Point, Quaternion
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import OccupancyGrid, Path, Odometry
from std_msgs.msg import Bool, String, Header
from visualization_msgs.msg import Marker, MarkerArray
from tf.transformations import euler_from_quaternion, quaternion_from_euler

class SLAMNavigationSystem:
    """
    SLAM tabanlƒ± navigasyon sistemi
    """
    
    def __init__(self):
        """
        SLAM Navigation ba≈ülatƒ±cƒ±
        """
        # ROS node ba≈ülat
        rospy.init_node('slam_navigation_system', anonymous=True)
        
        # Parametreler
        self.robot_frame = rospy.get_param('~robot_frame', 'base_link')
        self.laser_frame = rospy.get_param('~laser_frame', 'laser_frame')
        self.map_frame = rospy.get_param('~map_frame', 'map')
        self.odom_frame = rospy.get_param('~odom_frame', 'odom')
        
        # Navigasyon parametreleri
        self.max_linear_speed = rospy.get_param('~max_linear_speed', 0.5)  # m/s
        self.max_angular_speed = rospy.get_param('~max_angular_speed', 1.0)  # rad/s
        self.goal_tolerance = rospy.get_param('~goal_tolerance', 0.2)  # m
        self.obstacle_distance = rospy.get_param('~obstacle_distance', 0.5)  # m
        
        # Robot durumu
        self.current_pose = None
        self.current_goal = None
        self.laser_data = None
        self.is_navigating = False
        self.navigation_mode = "manual"  # "manual", "waypoint", "autonomous"
        
        # ROS Publishers
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=1)
        self.path_pub = rospy.Publisher('/planned_path', Path, queue_size=1)
        self.marker_pub = rospy.Publisher('/navigation_markers', MarkerArray, queue_size=10)
        self.status_pub = rospy.Publisher('/navigation_status', String, queue_size=1)
        
        # ROS Subscribers
        rospy.Subscriber('/scan', LaserScan, self.laser_callback)
        rospy.Subscriber('/odom', Odometry, self.odom_callback)
        rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.goal_callback)
        rospy.Subscriber('/navigation_cmd', String, self.navigation_command_callback)
        
        # TF
        self.tf_buffer = tf2_ros.Buffer()
        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        
        # Path planning
        self.waypoints = []
        self.current_waypoint_index = 0
        
        rospy.loginfo("üó∫Ô∏è SLAM Navigasyon Sistemi ba≈ülatƒ±ldƒ±")
        rospy.loginfo(f"üöó Robot frame: {self.robot_frame}")
        rospy.loginfo(f"üì° Laser frame: {self.laser_frame}")
    
    def laser_callback(self, msg):
        """
        Laser scan callback
        
        Args:
            msg: sensor_msgs/LaserScan
        """
        self.laser_data = msg
        
        # Obstacle detection i√ßin laser verilerini analiz et
        if self.is_navigating:
            self.check_obstacles()
    
    def odom_callback(self, msg):
        """
        Odometry callback
        
        Args:
            msg: nav_msgs/Odometry
        """
        self.current_pose = msg.pose.pose
    
    def goal_callback(self, msg):
        """
        Goal callback (RViz'den gelen hedef)
        
        Args:
            msg: geometry_msgs/PoseStamped
        """
        rospy.loginfo(f"üéØ Yeni hedef alƒ±ndƒ±: ({msg.pose.position.x:.2f}, {msg.pose.position.y:.2f})")
        self.current_goal = msg
        self.is_navigating = True
        self.navigation_mode = "waypoint"
    
    def navigation_command_callback(self, msg):
        """
        Navigasyon komut callback
        
        Args:
            msg: std_msgs/String
        """
        cmd = msg.data.lower()
        
        if cmd == "start_autonomous":
            self.start_autonomous_navigation()
        elif cmd == "stop":
            self.stop_navigation()
        elif cmd == "resume":
            self.resume_navigation()
        elif cmd.startswith("goto"):
            # "goto x,y" formatƒ±
            try:
                coords = cmd.split()[1].split(',')
                x, y = float(coords[0]), float(coords[1])
                self.goto_position(x, y)
            except:
                rospy.logwarn("‚ö†Ô∏è Ge√ßersiz goto komutu formatƒ±: goto x,y")
        elif cmd == "return_home":
            self.goto_position(0, 0)
    
    def check_obstacles(self):
        """
        Laser verilerini kullanarak engel kontrol√º
        """
        if not self.laser_data:
            return
        
        # √ñnde engel var mƒ± kontrol et
        ranges = np.array(self.laser_data.ranges)
        angle_increment = self.laser_data.angle_increment
        angle_min = self.laser_data.angle_min
        
        # √ñn kƒ±sƒ±m i√ßin a√ßƒ± aralƒ±ƒüƒ± (-45¬∞ - +45¬∞)
        front_start_angle = -math.pi/4
        front_end_angle = math.pi/4
        
        front_indices = []
        for i, r in enumerate(ranges):
            angle = angle_min + i * angle_increment
            if front_start_angle <= angle <= front_end_angle:
                if not math.isinf(r) and not math.isnan(r):
                    front_indices.append((i, r))
        
        if front_indices:
            min_distance = min([r for i, r in front_indices])
            
            if min_distance < self.obstacle_distance:
                rospy.logwarn(f"‚ö†Ô∏è Engel tespit edildi! Mesafe: {min_distance:.2f}m")
                self.handle_obstacle(min_distance)
    
    def handle_obstacle(self, distance):
        """
        Engel ile kar≈üƒ±la≈ütƒ±ƒüƒ±nda √ß√∂z√ºm stratejisi
        
        Args:
            distance: Engele olan mesafe
        """
        if distance < 0.3:  # √áok yakƒ±n engel
            # Dur ve geri git
            self.stop_robot()
            rospy.logwarn("üõë Acil durak - √ßok yakƒ±n engel!")
            
        elif distance < self.obstacle_distance:
            # Yava≈üla ve alternatif yol ara
            self.slow_down()
            # TODO: Obstacle avoidance algoritmasƒ±
            rospy.loginfo("üêå Yava≈ülatƒ±lƒ±yor - engel yakƒ±n")
    
    def goto_position(self, x, y, theta=0):
        """
        Belirtilen pozisyona git
        
        Args:
            x: X koordinatƒ±
            y: Y koordinatƒ±  
            theta: Y√∂nelim (rad)
        """
        # PoseStamped mesajƒ± olu≈ütur
        goal = PoseStamped()
        goal.header.frame_id = self.map_frame
        goal.header.stamp = rospy.Time.now()
        
        goal.pose.position.x = x
        goal.pose.position.y = y
        goal.pose.position.z = 0
        
        # Quaternion'a √ßevir
        quat = quaternion_from_euler(0, 0, theta)
        goal.pose.orientation.x = quat[0]
        goal.pose.orientation.y = quat[1]
        goal.pose.orientation.z = quat[2]
        goal.pose.orientation.w = quat[3]
        
        self.current_goal = goal
        self.is_navigating = True
        self.navigation_mode = "waypoint"
        
        rospy.loginfo(f"üéØ Hedefe gidiliyor: ({x:.2f}, {y:.2f}, {math.degrees(theta):.1f}¬∞)")
    
    def start_autonomous_navigation(self):
        """
        Otonom navigasyonu ba≈ülat (parkur modunda)
        """
        rospy.loginfo("üöÄ Otonom navigasyon ba≈ülatƒ±ldƒ±")
        self.navigation_mode = "autonomous"
        self.is_navigating = True
        
        # TEKNOFEST parkuru i√ßin waypoint'ler
        # Bu waypoint'ler tabela tanƒ±ma ile g√ºncellenecek
        self.waypoints = [
            (2.0, 0.0, 0),      # ƒ∞lk checkpoint
            (4.0, 2.0, math.pi/2),  # D√∂n√º≈ü noktasƒ±
            (6.0, 2.0, 0),      # D√ºz yol
            (8.0, 0.0, -math.pi/2), # Son d√∂n√º≈ü
            (10.0, 0.0, 0)      # Finish
        ]
        
        self.current_waypoint_index = 0
        self.goto_position(*self.waypoints[0])
    
    def simple_path_planning(self):
        """
        Basit path planning algoritmasƒ±
        (Geli≈ümi≈ü A* veya RRT* ile deƒüi≈ütirilebilir)
        """
        if not self.current_pose or not self.current_goal:
            return
        
        # ≈ûu anda basit d√ºz √ßizgi planlamasƒ±
        # Gelecekte obstacle avoidance ile geli≈ütirilecek
        
        path = Path()
        path.header.frame_id = self.map_frame
        path.header.stamp = rospy.Time.now()
        
        # Ba≈ülangƒ±√ß noktasƒ±
        start_pose = PoseStamped()
        start_pose.header = path.header
        start_pose.pose = self.current_pose
        path.poses.append(start_pose)
        
        # Hedef noktasƒ±
        path.poses.append(self.current_goal)
        
        # Path'i yayƒ±nla
        self.path_pub.publish(path)
    
    def navigate_to_goal(self):
        """
        Hedefe doƒüru navigasyon kontrol√º
        """
        if not self.current_pose or not self.current_goal:
            return
        
        # Mevcut pozisyon
        current_x = self.current_pose.position.x
        current_y = self.current_pose.position.y
        current_orientation = self.current_pose.orientation
        
        # Mevcut a√ßƒ±
        _, _, current_yaw = euler_from_quaternion([
            current_orientation.x, current_orientation.y,
            current_orientation.z, current_orientation.w
        ])
        
        # Hedef pozisyon
        goal_x = self.current_goal.pose.position.x
        goal_y = self.current_goal.pose.position.y
        
        # Hedef mesafe ve a√ßƒ±
        dx = goal_x - current_x
        dy = goal_y - current_y
        distance = math.sqrt(dx*dx + dy*dy)
        angle_to_goal = math.atan2(dy, dx)
        
        # A√ßƒ± farkƒ±
        angle_diff = angle_to_goal - current_yaw
        angle_diff = math.atan2(math.sin(angle_diff), math.cos(angle_diff))  # Normalize
        
        # Hedefe ula≈ütƒ± mƒ±?
        if distance < self.goal_tolerance:
            rospy.loginfo("‚úÖ Hedefe ula≈üƒ±ldƒ±!")
            self.goal_reached()
            return
        
        # Hareket komutlarƒ± hesapla
        cmd_vel = Twist()
        
        # √ñnce d√∂ner, sonra ilerler (basit strateji)
        if abs(angle_diff) > 0.1:  # 5.7 derece
            # Sadece d√∂n
            cmd_vel.angular.z = self.max_angular_speed * np.sign(angle_diff) * min(abs(angle_diff), 1.0)
        else:
            # ƒ∞lerle
            linear_speed = min(self.max_linear_speed, distance * 0.5)  # Yakla≈ütƒ±k√ßa yava≈üla
            cmd_vel.linear.x = linear_speed
            
            # Fine-tuning i√ßin k√º√ß√ºk a√ßƒ± d√ºzeltmesi
            cmd_vel.angular.z = angle_diff * 0.5
        
        # Komutu yayƒ±nla
        self.cmd_vel_pub.publish(cmd_vel)
    
    def goal_reached(self):
        """
        Hedefe ula≈üƒ±ldƒ±ƒüƒ±nda √ßaƒürƒ±lƒ±r
        """
        self.stop_robot()
        
        if self.navigation_mode == "autonomous" and self.waypoints:
            # Sonraki waypoint'e ge√ß
            self.current_waypoint_index += 1
            
            if self.current_waypoint_index < len(self.waypoints):
                rospy.loginfo(f"üìç Sonraki waypoint'e ge√ßiliyor: {self.current_waypoint_index}")
                self.goto_position(*self.waypoints[self.current_waypoint_index])
            else:
                rospy.loginfo("üèÅ T√ºm waypoint'ler tamamlandƒ±!")
                self.is_navigating = False
                self.navigation_mode = "manual"
        else:
            self.is_navigating = False
            rospy.loginfo("üéØ Waypoint navigasyonu tamamlandƒ±")
    
    def stop_robot(self):
        """
        Robotu durdur
        """
        cmd_vel = Twist()  # T√ºm deƒüerler 0
        self.cmd_vel_pub.publish(cmd_vel)
    
    def slow_down(self):
        """
        Robotu yava≈ülat
        """
        # Mevcut hƒ±zƒ±n yarƒ±sƒ±na d√º≈ü
        # Bu method navigate_to_goal i√ßinde implement edilecek
        pass
    
    def stop_navigation(self):
        """
        Navigasyonu durdur
        """
        self.is_navigating = False
        self.stop_robot()
        rospy.loginfo("üõë Navigasyon durduruldu")
    
    def resume_navigation(self):
        """
        Navigasyonu devam ettir
        """
        if self.current_goal:
            self.is_navigating = True
            rospy.loginfo("‚ñ∂Ô∏è Navigasyon devam ettirildi")
    
    def publish_status(self):
        """
        Navigasyon durumunu yayƒ±nla
        """
        status = {
            'mode': self.navigation_mode,
            'navigating': self.is_navigating,
            'waypoint_index': self.current_waypoint_index if self.waypoints else -1,
            'total_waypoints': len(self.waypoints)
        }
        
        status_msg = String()
        status_msg.data = str(status)
        self.status_pub.publish(status_msg)
    
    def run(self):
        """
        Ana √ßalƒ±≈ütƒ±rma d√∂ng√ºs√º
        """
        rospy.loginfo("üöÄ SLAM Navigasyon sistemi √ßalƒ±≈üƒ±yor")
        
        rate = rospy.Rate(10)  # 10 Hz
        
        try:
            while not rospy.is_shutdown():
                # Navigasyon aktifse hedefe git
                if self.is_navigating and self.current_goal:
                    self.navigate_to_goal()
                    self.simple_path_planning()
                
                # Status yayƒ±nla
                self.publish_status()
                
                rate.sleep()
                
        except KeyboardInterrupt:
            rospy.loginfo("üõë SLAM Navigasyon durduruluyor...")
            
        finally:
            self.stop_robot()

def main():
    """
    Ana fonksiyon
    """
    try:
        nav_system = SLAMNavigationSystem()
        nav_system.run()
        
    except rospy.ROSInterruptException:
        rospy.loginfo("üõë ROS interrupted")
    except Exception as e:
        rospy.logerr(f"‚ùå SLAM Navigation hatasƒ±: {e}")

if __name__ == "__main__":
    main()
